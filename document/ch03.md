# 3. SOLID 원칙

## 3.1 단일 책임 원칙 (SRP)

SRP(Single Responsibility Principle) 단일 책임 원칙

### 3.1.1 책임의 의미

객체지향 설계 관점에서 책임의 기본 단위 => 객체
* 즉 객체는 하나의 책임만 가져야한다.

#### 책임 ??
* 해야하는 것 
* 할 수 있는 것

**Keypoint** 
```
책임 = 해야하는 것
책임 = 할 수 있는 것
책임 = 해야하는 것을 잘 할 수 있는 것
```

++**학생이 너무 많은 일을 한다**++
```java
public class Student {
    /** 수강과목 조회 */
    public void getCources() {}

    /** 수강신청  **/
    public void addCourse(Course course) {}

    /**
     * 데이터베이스에 학생 정보를 저장
     **/
    public void save() {}

    /** 데이터베이스로 부터 학생 정보를 읽어오는 것 **/
    public Student load() {  return new Student();  }

    /** 성적표 출력   **/
    public void printOnReportCard() {  }

    /** 출석부 출력  **/
    public void printOnAttendanceBook() {  }
}
```

### 3.1.2 변경
설계 원칙을 학습 하는 이유는 예측하지 못한 변경사항이 발생하더라도 **==유연하고 확장성이 있도록 시스템 구조를 설계==**하기 위함이다


### 3.1.3 책임분리
**Keypoint** 
```
시스템에 변경이 발생할 때 기존의 기능에 영향을 주는지를 평갚하는 테스트를 회귀(regression) 테스트라 한다. 
회귀 테스트 비용을 줄이는 방법 하나는 시스템에 변경사항이 발생했을 때 영향을 받는 부분을 적게하는 것.
```

학생이라는 클래스를 여러 클래스로 책임 분리
학생 <-(학생 DAO, 성적표 , 출석부)

### 3.1.4 산탄총 수술
하나의 책임이 여러개의 클래스로 분리되어 있는 예
로깅, 보안, 트랜잭션과 같은 횡단 관심(cross-cutting concern) 

### 3.1.5 관심지향 프로그래밍과 횡단 관심 문제
AOP(Aspect-Oriented Programming)

**Keypoint**

| 용어 | 설명 |
|--------|--------|
| 조인포인트       |   애플리케이션 실행 중의 특정한 지점을 의미     |
| 어드바이스       |   특정 조인트포인트에 실행하는 코드를 의미     |
| 포인트컷       |   여러 조인트포인트의 집합체, 언제 어드바이스를 실행할지 정의할 때 사용한다.     |
| 에스펙트       |   어드바이스와 포인트컷을 조합한 조합물 즉, 애플리케이션이 가져야 할 로직과 그것을 실행해야 하는 지점을 정의한 것     |
| 위빙       |   애플리키이션 코드의 해당 지점에 애스펙트를 실제로 주입하는 과정, 컴파일 시점 위빙과 실행시점 위빙이 있다.     |


## 3.2 개방-폐쇄 원칙

OCP(Open-Closed Principle)
기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.
클래스를 변경하지 않고도 대상 클래스의 환경을 변경할 수 있는 설계가 되어야한다.

* 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
	* 기능을 변경하거나 확장 할 수 있으면서
	* 그 기능을 상요하는 코드는 수정하지 않다.

**Keypoint**
```
단위테스트 = 빠른 테스트
```
**Keypoint**
```
모의 객체 = 테스트용 가짜 객체
```

#### 개방 폐쇄 원치기 깨질 때의 주요 증상
* 다운 캐스팅을 한다.
* 비슷한 if-else 블록이 존재한다.

### 개방 폐쇄 원칙은 유연함에 대한 것

개방 폐쇄 원칙은 변화가 예상되는 것을 추상화해서 변경의 유연함을 얻도록 해준다. 이말은 변화되는 부분을 추상화하지 못하면(또는 안하면) 개방 폐쇄 원칙을 지킬 수 없게 되어 시간이 흐를수록 기능 벼경이나 확장을 어렵게 만든다는 것을 뜻한다. 따라서 코드에 대한 변화 요구가 발생하면, 변화와 관련된 구현을 추상화해서 개방 폐쇄 원칙에 맞게 수정할 수 있는지 확인하는 습관을 가져야한다.